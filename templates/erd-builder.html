<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ERD Builder - Real-time Preview</title>
    
    <!-- @hpcc-js/wasm - Modern Graphviz for Web -->
    <script src="https://cdn.jsdelivr.net/npm/@hpcc-js/wasm@2.5.0/dist/graphviz.umd.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            background: white;
            margin: 20px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        /* Left Panel - Form */
        .form-panel {
            width: 400px;
            background: #f8f9fa;
            padding: 25px;
            overflow-y: auto;
            border-right: 3px solid #dee2e6;
        }

        .form-panel h2 {
            color: #2c3e50;
            font-size: 24px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s;
            font-family: inherit;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            margin-top: 20px;
        }

        .section-header h3 {
            color: #2c3e50;
            font-size: 18px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #ffc107;
            color: #000;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
            padding: 6px 10px;
            font-size: 12px;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn-info:hover {
            background: #138496;
        }

        /* Entity Card */
        .entity-card {
            background: white;
            padding: 15px;
            margin-bottom: 12px;
            border-radius: 8px;
            border: 2px solid #dee2e6;
            transition: all 0.3s;
        }

        .entity-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .entity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .entity-header h4 {
            color: #2c3e50;
            font-size: 15px;
        }

        .attribute-list {
            margin-top: 10px;
        }

        .attribute-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
        }

        .attribute-item.primary-key {
            background: #fff3cd;
            font-weight: 600;
        }

        .add-attribute {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .add-attribute input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 12px;
        }

        .empty-state {
            padding: 30px;
            text-align: center;
            color: #6c757d;
            background: white;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }

        /* Right Panel - Preview */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
            padding: 20px;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .preview-header h3 {
            color: #2c3e50;
            font-size: 20px;
        }

        .preview-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .preview-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            border: 2px solid #dee2e6;
            overflow: auto;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .preview-container svg {
            max-width: 100%;
            height: auto;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.95);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
        }

        .loading-overlay.show {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info-box {
            margin-top: 15px;
            padding: 12px;
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            font-size: 13px;
            color: #0c5460;
        }

        .success-box {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .action-buttons button {
            flex: 1;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .badge-success {
            background: #28a745;
            color: white;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Form -->
        <div class="form-panel">
            <h2>
                üìä ERD Builder 
                <span class="badge badge-success">HPCC</span>
            </h2>

            <!-- ERD Name -->
            <div class="form-group">
                <label>Nama ERD:</label>
                <input type="text" id="erdName" placeholder="Masukkan nama ERD">
            </div>

            <!-- Entities Section -->
            <div class="section-header">
                <h3>Entitas</h3>
                <button class="btn btn-primary" onclick="addEntity()">+ Tambah</button>
            </div>
            <div id="entitiesContainer"></div>

            <!-- Relationships Section -->
            <div class="section-header">
                <h3>Relasi</h3>
                <button class="btn btn-warning" onclick="addRelationship()">+ Tambah</button>
            </div>
            <div id="relationshipsContainer"></div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="btn btn-success" onclick="saveERD()">
                    üíæ Simpan
                </button>
            </div>

            <div class="info-box" style="margin-top: 15px;">
                <strong>‚ÑπÔ∏è Preview Real-time:</strong> Menggunakan @hpcc-js/wasm (Graphviz WebAssembly). 
                Preview akan otomatis update saat Anda mengetik!
            </div>
        </div>

        <!-- Right Panel: Preview -->
        <div class="preview-panel">
            <div class="preview-header">
                <h3>üñºÔ∏è Preview ERD</h3>
                <div class="preview-controls">
                    <button class="btn btn-info" onclick="downloadSVG()">
                        ‚¨áÔ∏è Download SVG
                    </button>
                    <button class="btn btn-info" onclick="downloadPNG()">
                        ‚¨áÔ∏è Download PNG
                    </button>
                </div>
            </div>

            <div class="preview-container" id="previewContainer">
                <div class="empty-state">
                    <h3>Preview akan muncul di sini</h3>
                    <p>Tambahkan entitas dan klik "Update Preview"</p>
                </div>
                
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <p style="margin-top: 15px; color: #667eea; font-weight: 600;">
                        Generating ERD...
                    </p>
                </div>
            </div>

            <div class="info-box success-box" id="successMessage" style="display: none;">
                <strong>‚úÖ Berhasil!</strong> <span id="successText"></span>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let entities = [];
        let relationships = [];
        let entityCounter = 0;
        let relationshipCounter = 0;
        let currentSVG = null;
        let graphviz = null;

        // Initialize @hpcc-js/wasm Graphviz
        async function initGraphviz() {
            try {
                console.log('Initializing @hpcc-js/wasm Graphviz...');
                const wasmFolder = await window["@hpcc-js/wasm"];
                graphviz = await wasmFolder.Graphviz.load();
                console.log('‚úÖ Graphviz initialized successfully');
                return true;
            } catch (error) {
                console.error('‚ùå Failed to initialize Graphviz:', error);
                alert('Gagal memuat Graphviz. Silakan refresh halaman.');
                return false;
            }
        }

        // Initialize on page load
        window.addEventListener('load', async function() {
            await initGraphviz();
            renderEntitiesForm();
            renderRelationshipsForm();
        });

        // Add Entity
        function addEntity() {
            const entity = {
                id: `entity_${++entityCounter}`,
                name: '',
                attributes: [],
                primary_key: ''
            };
            entities.push(entity);
            renderEntitiesForm();
            updatePreview(); // Auto update preview when adding entity
        }

        // Remove Entity
        function removeEntity(id) {
            const entity = entities.find(e => e.id === id);
            entities = entities.filter(e => e.id !== id);
            
            if (entity) {
                relationships = relationships.filter(r => 
                    r.entity1 !== entity.name && r.entity2 !== entity.name
                );
            }
            
            renderEntitiesForm();
            renderRelationshipsForm();
            updatePreview(); // Auto update preview when removing entity
        }

        // Add Relationship
        function addRelationship() {
            if (entities.length < 2) {
                alert('Minimal 2 entitas diperlukan untuk membuat relasi');
                return;
            }
            const rel = {
                id: `rel_${++relationshipCounter}`,
                entity1: '',
                entity2: '',
                relation: '',
                type: 'one-to-many',
                layout: 'LR'
            };
            relationships.push(rel);
            renderRelationshipsForm();
            updatePreview(); // Auto update preview when adding relationship
        }

        // Remove Relationship
        function removeRelationship(id) {
            relationships = relationships.filter(r => r.id !== id);
            renderRelationshipsForm();
            updatePreview(); // Auto update preview when removing relationship
        }

        // Update functions with debounce for better performance
        function updateEntity(id, field, value) {
            const entity = entities.find(e => e.id === id);
            if (entity) {
                entity[field] = value;
                renderRelationshipsForm();
                debounceUpdate(() => updatePreview()); // Debounced auto update
            }
        }

        function updateRelationship(id, field, value) {
            const rel = relationships.find(r => r.id === id);
            if (rel) {
                rel[field] = value;
                debounceUpdate(() => updatePreview()); // Debounced auto update
            }
        }

        function addAttribute(entityId) {
            const input = document.getElementById(`newAttr_${entityId}`);
            const attrName = input.value.trim();
            if (!attrName) return;

            const entity = entities.find(e => e.id === entityId);
            if (entity) {
                entity.attributes.push(attrName);
                input.value = '';
                renderEntitiesForm();
                updatePreview(); // Instant update for adding
            }
        }

        function removeAttribute(entityId, index) {
            console.log('Removing attribute:', entityId, index);
            const entity = entities.find(e => e.id === entityId);
            if (entity) {
                console.log('Before:', entity.attributes);
                entity.attributes.splice(index, 1);
                console.log('After:', entity.attributes);
                renderEntitiesForm();
                updatePreview(); // Instant update for removing
            } else {
                console.log('Entity not found:', entityId);
            }
        }

        // Render forms
        function renderEntitiesForm() {
            const container = document.getElementById('entitiesContainer');
            
            if (entities.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        Belum ada entitas. Klik "Tambah" untuk membuat entitas baru.
                    </div>
                `;
                return;
            }

            container.innerHTML = entities.map((entity, idx) => `
                <div class="entity-card">
                    <div class="entity-header">
                        <h4>Entitas ${idx + 1}</h4>
                        <button class="btn btn-danger" onclick="removeEntity('${entity.id}')">
                            üóëÔ∏è
                        </button>
                    </div>

                    <div class="form-group">
                        <label>Nama Entitas:</label>
                        <input type="text" value="${entity.name}" 
                               oninput="updateEntity('${entity.id}', 'name', this.value)"
                               placeholder="Nama entitas">
                    </div>

                    <div class="form-group">
                        <label>Primary Key:</label>
                        <input type="text" value="${entity.primary_key}" 
                               oninput="updateEntity('${entity.id}', 'primary_key', this.value)"
                               placeholder="Primary key (opsional)">
                    </div>

                    <div class="attribute-list">
                        <label>Atribut:</label>
                        ${entity.attributes.map((attr, i) => `
                            <div class="attribute-item ${attr === entity.primary_key ? 'primary-key' : ''}">
                                <span>${attr} ${attr === entity.primary_key ? 'üîë' : ''}</span>
                                <button class="btn btn-danger" style="padding: 2px 6px; font-size: 11px;"
                                        type="button"
                                        onclick="removeAttribute('${entity.id}', ${i}); return false;">√ó</button>
                            </div>
                        `).join('')}

                        <div class="add-attribute">
                            <input type="text" id="newAttr_${entity.id}" 
                                   placeholder="Atribut baru"
                                   onkeypress="if(event.key==='Enter') { event.preventDefault(); addAttribute('${entity.id}'); return false; }">
                            <button class="btn btn-success" style="padding: 6px 10px;"
                                    type="button"
                                    onclick="addAttribute('${entity.id}'); return false;">+</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function renderRelationshipsForm() {
            const container = document.getElementById('relationshipsContainer');
            
            if (relationships.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        Belum ada relasi. Klik "Tambah" untuk membuat relasi baru.
                    </div>
                `;
                return;
            }

            container.innerHTML = relationships.map((rel, idx) => `
                <div class="entity-card">
                    <div class="entity-header">
                        <h4>Relasi ${idx + 1}</h4>
                        <button class="btn btn-danger" onclick="removeRelationship('${rel.id}')">üóëÔ∏è</button>
                    </div>

                    <div class="form-group">
                        <label>Entitas 1:</label>
                        <select onchange="updateRelationship('${rel.id}', 'entity1', this.value)">
                            <option value="">Pilih entitas</option>
                            ${entities.map(e => `
                                <option value="${e.name}" ${rel.entity1 === e.name ? 'selected' : ''}>
                                    ${e.name || 'Unnamed'}
                                </option>
                            `).join('')}
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Entitas 2:</label>
                        <select onchange="updateRelationship('${rel.id}', 'entity2', this.value)">
                            <option value="">Pilih entitas</option>
                            ${entities.map(e => `
                                <option value="${e.name}" ${rel.entity2 === e.name ? 'selected' : ''}>
                                    ${e.name || 'Unnamed'}
                                </option>
                            `).join('')}
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Nama Relasi:</label>
                        <input type="text" value="${rel.relation}"
                               oninput="updateRelationship('${rel.id}', 'relation', this.value)"
                               placeholder="Nama relasi">
                    </div>

                    <div class="form-group">
                        <label>Kardinalitas:</label>
                        <select onchange="updateRelationship('${rel.id}', 'type', this.value)">
                            <option value="one-to-one" ${rel.type === 'one-to-one' ? 'selected' : ''}>One to One</option>
                            <option value="one-to-many" ${rel.type === 'one-to-many' ? 'selected' : ''}>One to Many</option>
                            <option value="many-to-one" ${rel.type === 'many-to-one' ? 'selected' : ''}>Many to One</option>
                            <option value="many-to-many" ${rel.type === 'many-to-many' ? 'selected' : ''}>Many to Many</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Layout:</label>
                        <select onchange="updateRelationship('${rel.id}', 'layout', this.value)">
                            <option value="LR" ${rel.layout === 'LR' ? 'selected' : ''}>Left to Right</option>
                            <option value="RL" ${rel.layout === 'RL' ? 'selected' : ''}>Right to Left</option>
                            <option value="TB" ${rel.layout === 'TB' ? 'selected' : ''}>Top to Bottom</option>
                            <option value="BT" ${rel.layout === 'BT' ? 'selected' : ''}>Bottom to Top</option>
                        </select>
                    </div>
                </div>
            `).join('');
        }

        // Calculate positions for entities based on relationship layout hints
        function calculateEntityPositions() {
            const numEntities = entities.length;
            if (numEntities === 0) return {};
            
            // Adaptive spacing based on number of entities
            let xSpacing, ySpacing;
            if (numEntities > 15) {
                xSpacing = 35.0;
            } else if (numEntities > 12) {
                xSpacing = 25.0;
            } else if (numEntities >= 10) {
                xSpacing = 15.0;
            } else if (numEntities >= 4) {
                xSpacing = 6.0;
            } else {
                xSpacing = 3.0;
            }
            ySpacing = xSpacing - 1.1;
            
            const positions = {};
            const placed = new Set();
            
            // Build relationship graph
            const relGraph = {};
            relationships.forEach(rel => {
                const e1 = rel.entity1;
                const e2 = rel.entity2;
                const layout = (rel.layout || 'TB').toUpperCase();
                
                if (!relGraph[e1]) relGraph[e1] = [];
                if (!relGraph[e2]) relGraph[e2] = [];
                
                relGraph[e1].push({ to: e2, layout: layout });
                
                // Reverse layout for backward connection
                const reverseLayout = {
                    'LR': 'RL', 'RL': 'LR', 
                    'TB': 'BT', 'BT': 'TB'
                }[layout] || layout;
                relGraph[e2].push({ to: e1, layout: reverseLayout });
            });
            
            // Find root entity (prefer TB/BT layouts)
            let root = null;
            for (const rel of relationships) {
                if (['TB', 'BT'].includes((rel.layout || 'TB').toUpperCase())) {
                    root = rel.entity1;
                    break;
                }
            }
            if (!root && entities.length > 0) {
                root = entities[0].name.trim() || 'Entitas_1';
            }
            
            // Place root at origin
            if (root) {
                positions[root] = { x: 0, y: 0 };
                placed.add(root);
            }
            
            // BFS to place connected entities
            const queue = [root];
            let iteration = 0;
            const maxIterations = numEntities * 10;
            
            while (queue.length > 0 && iteration < maxIterations) {
                iteration++;
                const current = queue.shift();
                const currentPos = positions[current];
                
                if (!currentPos || !relGraph[current]) continue;
                
                relGraph[current].forEach(conn => {
                    const target = conn.to;
                    const layout = conn.layout;
                    
                    if (!placed.has(target)) {
                        let newPos = { x: 0, y: 0 };
                        
                        switch (layout) {
                            case 'TB':
                                newPos = { x: currentPos.x, y: currentPos.y + ySpacing };
                                break;
                            case 'BT':
                                newPos = { x: currentPos.x, y: currentPos.y - ySpacing };
                                break;
                            case 'LR':
                                newPos = { x: currentPos.x + xSpacing, y: currentPos.y };
                                break;
                            case 'RL':
                                newPos = { x: currentPos.x - xSpacing, y: currentPos.y };
                                break;
                            default:
                                newPos = { x: currentPos.x + xSpacing, y: currentPos.y };
                        }
                        
                        positions[target] = newPos;
                        placed.add(target);
                        queue.push(target);
                    }
                });
            }
            
            // Place unconnected entities
            entities.forEach((entity, idx) => {
                const entityName = entity.name.trim() || `Entitas_${idx + 1}`;
                if (!placed.has(entityName)) {
                    positions[entityName] = { 
                        x: (idx + 1) * xSpacing, 
                        y: 0 
                    };
                }
            });
            
            return positions;
        }

        // Get relationship directions from an entity
        function getRelationshipDirections(entityName, positions) {
            const directions = [];
            const entityPos = positions[entityName];
            if (!entityPos) return directions;
            
            relationships.forEach(rel => {
                let otherEntity = null;
                if (rel.entity1 === entityName) {
                    otherEntity = rel.entity2;
                } else if (rel.entity2 === entityName) {
                    otherEntity = rel.entity1;
                }
                
                if (otherEntity && positions[otherEntity]) {
                    const otherPos = positions[otherEntity];
                    const dx = otherPos.x - entityPos.x;
                    const dy = otherPos.y - entityPos.y;
                    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    directions.push({ angle, distance, entity: otherEntity });
                }
            });
            
            return directions;
        }

        // Distribute attributes smartly (avoiding relationship directions)
        function distributeAttributes(entityName, entityPos, attrs, positions) {
            const numAttrs = attrs.length;
            if (numAttrs === 0) return {};
            
            const attrPositions = {};
            const relDirections = getRelationshipDirections(entityName, positions);
            
            // Adaptive radius based on entity count
            const numEntities = entities.length;
            let baseRadius, clearance;
            if (numEntities > 15) {
                baseRadius = 2.5;
                clearance = 80;
            } else if (numEntities > 12) {
                baseRadius = 2.2;
                clearance = 70;
            } else if (numEntities > 10) {
                baseRadius = 2.0;
                clearance = 60;
            } else if (numEntities >= 4) {
                baseRadius = 1.5;
                clearance = 50;
            } else {
                baseRadius = 1.2;
                clearance = 40;
            }
            
            // Block angles where relationships exist
            const blockedRanges = [];
            relDirections.forEach(relDir => {
                const angle = ((relDir.angle % 360) + 360) % 360;
                const startBlock = ((angle - clearance) % 360 + 360) % 360;
                const endBlock = ((angle + clearance) % 360 + 360) % 360;
                blockedRanges.push({ start: startBlock, end: endBlock });
            });
            
            // Find candidate angles (every 10 degrees)
            const candidateAngles = [];
            for (let angle = 0; angle < 360; angle += 10) {
                let isBlocked = false;
                for (const range of blockedRanges) {
                    if (range.start <= range.end) {
                        if (angle >= range.start && angle <= range.end) {
                            isBlocked = true;
                            break;
                        }
                    } else {
                        if (angle >= range.start || angle <= range.end) {
                            isBlocked = true;
                            break;
                        }
                    }
                }
                if (!isBlocked) {
                    candidateAngles.push(angle);
                }
            }
            
            // Fallback if not enough candidate angles
            const availableAngles = candidateAngles.length >= numAttrs 
                ? candidateAngles 
                : Array.from({ length: 36 }, (_, i) => i * 10);
            
            // Select angles for attributes
            const selectedAngles = [];
            if (numAttrs <= availableAngles.length) {
                const step = availableAngles.length / numAttrs;
                for (let i = 0; i < numAttrs; i++) {
                    selectedAngles.push(availableAngles[Math.floor(i * step)]);
                }
            } else {
                selectedAngles.push(...availableAngles);
                while (selectedAngles.length < numAttrs) {
                    selectedAngles.push(90);
                }
            }
            
            // Calculate positions
            attrs.forEach((attr, i) => {
                const angle = selectedAngles[i];
                const angleRad = (angle * Math.PI) / 180;
                const radius = baseRadius * (1.0 + (i % 3) * 0.15);
                
                const attrX = entityPos.x + radius * Math.cos(angleRad);
                const attrY = entityPos.y + radius * Math.sin(angleRad);
                
                attrPositions[attr] = { x: attrX, y: attrY };
            });
            
            return attrPositions;
        }

        // Generate DOT notation with smart positioning
        function generateDOT() {
            const erdName = document.getElementById('erdName').value.trim() || 'ERD';
            const numEntities = entities.length;
            
            let dot = 'digraph ERD {\n';
            dot += '  bgcolor="white";\n';
            dot += '  layout="neato";\n';
            
            // Adaptive overlap settings
            if (numEntities <= 7) {
                dot += '  overlap="scale";\n';
                dot += '  sep="+0.5";\n';
            } else if (numEntities <= 10) {
                dot += '  overlap="scalexy";\n';
                dot += '  sep="+2.0";\n';
            } else if (numEntities <= 15) {
                dot += '  overlap="vpsc";\n';
                dot += '  sep="+2.5";\n';
            } else {
                dot += '  overlap="false";\n';
                dot += '  sep="+3.0";\n';
            }
            
            dot += '  splines="line";\n';
            dot += '  node [fontname="Arial"];\n';
            dot += '  edge [fontname="Arial"];\n\n';

            const positions = calculateEntityPositions();
            const usePinning = numEntities <= 7 || numEntities > 15;
            
            // Add entities with positions
            entities.forEach((entity, idx) => {
                const entityName = entity.name.trim() || `Entitas_${idx + 1}`;
                const pos = positions[entityName];
                const posStr = usePinning ? `${pos.x},${pos.y}!` : `${pos.x},${pos.y}`;
                
                dot += `  "${entityName}" [\n`;
                dot += `    shape=box,\n`;
                dot += `    style=filled,\n`;
                dot += `    fillcolor="#2C3E50",\n`;
                dot += `    fontcolor="white",\n`;
                dot += `    fontname="Arial Bold",\n`;
                dot += `    fontsize=11,\n`;
                dot += `    width=1.8,\n`;
                dot += `    height=0.7,\n`;
                dot += `    pos="${posStr}"\n`;
                dot += `  ];\n`;
                
                // Add attributes with smart positioning
                const attrPositions = distributeAttributes(
                    entityName, 
                    pos, 
                    entity.attributes,
                    positions
                );
                
                entity.attributes.forEach(attr => {
                    const attrPos = attrPositions[attr];
                    const attrId = `${entityName}_${attr}`.replace(/\s+/g, '_');
                    const attrPosStr = usePinning 
                        ? `${attrPos.x},${attrPos.y}!` 
                        : `${attrPos.x},${attrPos.y}`;
                    
                    const isPK = attr === entity.primary_key;
                    const fillcolor = isPK ? '#F39C12' : '#27AE60';
                    const fontcolor = isPK ? '#2C3E50' : 'white';
                    const fontname = isPK ? 'Arial Bold' : 'Arial';
                    const label = isPK ? `<<U>${attr}</U>>` : attr;
                    
                    dot += `  "${attrId}" [\n`;
                    dot += `    shape=ellipse,\n`;
                    dot += `    style=filled,\n`;
                    dot += `    fillcolor="${fillcolor}",\n`;
                    dot += `    fontcolor="${fontcolor}",\n`;
                    dot += `    fontname="${fontname}",\n`;
                    dot += `    fontsize=9,\n`;
                    dot += `    width=1.2,\n`;
                    dot += `    height=0.5,\n`;
                    dot += `    label=${label},\n`;
                    dot += `    pos="${attrPosStr}"\n`;
                    dot += `  ];\n`;
                    
                    dot += `  "${attrId}" -> "${entityName}" [arrowhead=none, penwidth=0.5];\n`;
                });
                
                dot += '\n';
            });

            // Add relationships with positioned diamonds
            relationships.forEach((rel, i) => {
                if (!rel.entity1 || !rel.entity2) return;
                
                const e1Pos = positions[rel.entity1];
                const e2Pos = positions[rel.entity2];
                
                if (!e1Pos || !e2Pos) return;
                
                const relName = rel.relation.trim() || `Relasi_${i + 1}`;
                const relId = `rel_${i + 1}`;
                
                // Position diamond in the middle
                const relX = (e1Pos.x + e2Pos.x) / 2;
                const relY = (e1Pos.y + e2Pos.y) / 2;
                const relPosStr = usePinning ? `${relX},${relY}!` : `${relX},${relY}`;
                
                dot += `  "${relId}" [\n`;
                dot += `    shape=diamond,\n`;
                dot += `    style=filled,\n`;
                dot += `    fillcolor="#F39C12",\n`;
                dot += `    fontcolor="white",\n`;
                dot += `    fontname="Arial Bold",\n`;
                dot += `    fontsize=10,\n`;
                dot += `    label="${relName}",\n`;
                dot += `    width=1.4,\n`;
                dot += `    height=0.8,\n`;
                dot += `    pos="${relPosStr}"\n`;
                dot += `  ];\n`;
                
                const card = getCardinality(rel.type);
                
                dot += `  "${rel.entity1}" -> "${relId}" [\n`;
                dot += `    label="${card.entity1}",\n`;
                dot += `    arrowhead=none,\n`;
                dot += `    fontsize=10,\n`;
                dot += `    fontname="Arial Bold",\n`;
                dot += `    fontcolor="#2C3E50",\n`;
                dot += `    penwidth=1.5\n`;
                dot += `  ];\n`;
                
                dot += `  "${relId}" -> "${rel.entity2}" [\n`;
                dot += `    label="${card.entity2}",\n`;
                dot += `    arrowhead=none,\n`;
                dot += `    fontsize=10,\n`;
                dot += `    fontname="Arial Bold",\n`;
                dot += `    fontcolor="#2C3E50",\n`;
                dot += `    penwidth=1.5\n`;
                dot += `  ];\n\n`;
            });

            dot += '}\n';
            return dot;
        }

        function getCardinality(type) {
            const map = {
                'one-to-one': { entity1: '1', entity2: '1' },
                'one-to-many': { entity1: '1', entity2: 'N' },
                'many-to-one': { entity1: 'N', entity2: '1' },
                'many-to-many': { entity1: 'N', entity2: 'N' }
            };
            return map[type] || { entity1: '1', entity2: 'N' };
        }

        // Debounce function to avoid too many rapid updates
        let updateTimeout = null;
        function debounceUpdate(func, delay = 500) {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(func, delay);
        }

        // Update preview with @hpcc-js/wasm
        async function updatePreview() {
            if (entities.length === 0) {
                document.getElementById('previewContainer').innerHTML = `
                    <div class="empty-state">
                        <h3>Preview akan muncul di sini</h3>
                        <p>Tambahkan entitas untuk melihat preview</p>
                    </div>
                `;
                return;
            }

            try {
                // Check if Graphviz is initialized
                if (!graphviz) {
                    console.log('Graphviz not initialized, initializing now...');
                    const success = await initGraphviz();
                    if (!success) {
                        throw new Error('Failed to initialize Graphviz');
                    }
                }

                const dot = generateDOT();
                console.log('Generated DOT:', dot);

                // Render with @hpcc-js/wasm using correct method
                const svg = graphviz.dot(dot);
                
                // Display in preview container
                const container = document.getElementById('previewContainer');
                
                // Clear previous content including loading overlay
                const loadingOverlay = container.querySelector('.loading-overlay');
                container.innerHTML = '';
                
                // Re-add loading overlay
                if (loadingOverlay) {
                    container.appendChild(loadingOverlay);
                }
                
                // Add SVG
                container.innerHTML = svg + (loadingOverlay ? loadingOverlay.outerHTML : '');
                
                // Get the SVG element for download functionality
                currentSVG = container.querySelector('svg');
                
                // Make SVG responsive
                if (currentSVG) {
                    currentSVG.style.maxWidth = '100%';
                    currentSVG.style.height = 'auto';
                }

                console.log('‚úÖ Preview updated successfully');
            } catch (error) {
                console.error('‚ùå Error generating preview:', error);
                document.getElementById('previewContainer').innerHTML = `
                    <div class="empty-state" style="color: #dc3545;">
                        <h3>‚ùå Error</h3>
                        <p>${error.message}</p>
                        <p style="font-size: 12px; margin-top: 10px;">Check console for details</p>
                    </div>
                    <div class="loading-overlay" id="loadingOverlay">
                        <div class="spinner"></div>
                        <p style="margin-top: 15px; color: #667eea; font-weight: 600;">
                            Generating ERD...
                        </p>
                    </div>
                `;
            }
        }

        // Download SVG
        function downloadSVG() {
            if (!currentSVG) {
                alert('Silakan generate preview terlebih dahulu');
                return;
            }

            const erdName = document.getElementById('erdName').value.trim() || 'erd';
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(currentSVG);
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${erdName}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Download PNG
        function downloadPNG() {
            if (!currentSVG) {
                alert('Silakan generate preview terlebih dahulu');
                return;
            }

            const erdName = document.getElementById('erdName').value.trim() || 'erd';
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(currentSVG);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = function() {
                canvas.width = img.naturalWidth || 1200;
                canvas.height = img.naturalHeight || 800;
                
                // White background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw image
                ctx.drawImage(img, 0, 0);
                
                // Convert to blob
                canvas.toBlob(function(blob) {
                    if (!blob) {
                        alert('Failed to create PNG');
                        return;
                    }
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${erdName}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 'image/png', 1.0);
            };
            
            img.onerror = function(error) {
                console.error('Image load error:', error);
                alert('Failed to load SVG for PNG conversion');
            };
            
            const svgBlob = new Blob([svgString], { 
                type: 'image/svg+xml;charset=utf-8' 
            });
            img.src = URL.createObjectURL(svgBlob);
        }

        // Save ERD to backend
        async function saveERD() {
            const erdName = document.getElementById('erdName').value.trim();
            
            if (!erdName) {
                alert('Nama ERD harus diisi!');
                return;
            }

            if (entities.length === 0) {
                alert('Minimal harus ada 1 entitas!');
                return;
            }

            // Validate entities have names
            const unnamedEntities = entities.filter(e => !e.name.trim());
            if (unnamedEntities.length > 0) {
                alert('Semua entitas harus memiliki nama!');
                return;
            }

            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.classList.add('show');

            try {
                // Get SVG data
                let svgData = '';
                if (currentSVG) {
                    const serializer = new XMLSerializer();
                    svgData = serializer.serializeToString(currentSVG);
                }

                // Prepare ERD data
                const erdData = {
                    name: erdName.toLowerCase().replace(/\s+/g, '_'),
                    display_name: erdName,
                    entities: entities.map(e => ({
                        name: e.name,
                        attributes: e.attributes,
                        primary_key: e.primary_key || e.attributes[0] || ''
                    })),
                    relationships: relationships.map(r => ({
                        entity1: r.entity1,
                        entity2: r.entity2,
                        relation: r.relation,
                        type: r.type,
                        layout: r.layout
                    })),
                    svg_data: svgData,
                    rendering_engine: 'hpcc-wasm',
                    mode: 'manual'
                };

                console.log('Saving ERD data:', erdData);

                // Send to backend
                const response = await fetch('/api/erd/save-from-vizjs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify(erdData)
                });

                const result = await response.json();

                if (response.ok) {
                    // Show success message
                    const successMsg = document.getElementById('successMessage');
                    const successText = document.getElementById('successText');
                    successText.textContent = 'ERD berhasil disimpan ke database!';
                    successMsg.style.display = 'block';

                    console.log('Save successful:', result);

                    // Hide success message after 5 seconds
                    setTimeout(() => {
                        successMsg.style.display = 'none';
                    }, 5000);
                } else {
                    alert('Error: ' + (result.error || 'Gagal menyimpan ERD'));
                }
            } catch (error) {
                console.error('Error saving ERD:', error);
                alert('Error: ' + error.message);
            } finally {
                loadingOverlay.classList.remove('show');
            }
        }

        // Reset form
        function resetForm() {
            entities = [];
            relationships = [];
            entityCounter = 0;
            relationshipCounter = 0;
            currentSVG = null;
            
            document.getElementById('erdName').value = '';
            renderEntitiesForm();
            renderRelationshipsForm();
            
            document.getElementById('previewContainer').innerHTML = `
                <div class="empty-state">
                    <h3>Preview akan muncul di sini</h3>
                    <p>Tambahkan entitas dan klik "Update Preview"</p>
                </div>
            `;
            
            document.getElementById('successMessage').style.display = 'none';
        }
    </script>
</body>
</html>